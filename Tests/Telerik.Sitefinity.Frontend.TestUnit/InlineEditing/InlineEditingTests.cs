using System;
using System.IO;
using global::Microsoft.VisualStudio.TestTools.UnitTesting;
using Telerik.Sitefinity.Frontend.InlineEditing;
using Telerik.Sitefinity.Frontend.TestUtilities.DummyClasses.Models;
using Telerik.Sitefinity.Utilities.HtmlParsing;

namespace Telerik.Sitefinity.Frontend.TestUnit.InlineEditing
{
    /// <summary>
    /// Tests the InlineEditing functionality.
    /// </summary>
    [TestClass]
    public class InlineEditingTests
    {
        #region Public Methods and Operators

        /// <summary>
        /// The create inline editing region_ dummy content_ is wrapped into inline editing region.
        /// </summary>
        [TestMethod]
        [Owner("Bonchev")]
        [Description("Checks whether CreateInlineEditingRegion method of the HtmlProcessor class properly wraps a given HTML content into a InlineEditing region.")]
        public void CreateInlineEditingRegion_DummyContent_IsWrappedIntoInlineEditingRegion()
        {
            // Arrange: create dummy data which will be set to the related attributes inside the region div tag
            TextWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
            var providerName = "dummyProvider";
            var type = "dummyType";
            Guid id = Guid.NewGuid();

            // Act: create the CreateInlineEditingRegion
            var htmlProcessor = new HtmlProcessor(isInlineEditing: true);

            using (htmlProcessor.CreateInlineEditingRegion(writer, providerName, type, id))
            {
                writer.WriteLine(this.dummyContent);
            }

            string outPut = writer.ToString();

            // Assert: Parses the generated by the htmlTransformationProxy HTML checks if the HTML content is properly wrapped into a div tag
            // which has the required by the InlineEditing attributes
            // and these attributes has a proper data assigned
            using (var parser = new HtmlParser(outPut))
            {
                HtmlChunk chunk = parser.ParseNext();
                Assert.IsNotNull(chunk);

                // checks if the HTML tag is of type div and if it has the required attributes
                Assert.IsTrue(chunk.TagName.Equals(this.htmlWrapperTag, StringComparison.Ordinal));
                Assert.IsTrue(chunk.HasAttribute(this.idAttribute), "The id of the item is not appended as attribute correctly.");
                Assert.IsTrue(chunk.HasAttribute(this.providerAttribute), "The provider is not appended as attribute correctly.");
                Assert.IsTrue(chunk.HasAttribute(this.typeAttribute), "The id type the item is not appended as attribute correctly.");

                // checks if the required attributes has proper values assigned to them
                Assert.AreEqual(providerName, chunk.GetParamValue(this.providerAttribute), "The value of the provider attribute is not correct.");
                Assert.AreEqual(type, chunk.GetParamValue(this.typeAttribute), "The value of the provider attribute is not correct.");
                Assert.AreEqual(id.ToString(), chunk.GetParamValue(this.idAttribute), "The value of the id attribute is not correct.");

                this.AssertContentAndCloseTag(parser);
            }
        }

        /// <summary>
        /// The get string content_ with inline editing attribute_ text elelement properly created.
        /// </summary>
        [TestMethod]
        [Owner("Bonchev")]
        [Description("Checks whether GetStringContent method of the HtmlProcessor class properly wraps a given HTML content into a InlineEditing region for a property of the model which is marked with FieldInfoAttribute.")]
        public void GetStringContent_WithInlineEditingAttribute_TextElementProperlyCreated()
        {
            // Arrange
            var htmlProcessor = new HtmlProcessor(isInlineEditing: true);
            var dummyWidgetModel = new DummyWidgetModel { EditableContent = this.dummyContent, NonEditableContent = this.dummyContent };

            var fieldName = "DummyWidget";
            var type = "LongText";

            // Act
            string inlineeditingAwareContent = htmlProcessor.GetStringContent(dummyWidgetModel, "EditableContent");

            // Assert
            using (var parser = new HtmlParser(inlineeditingAwareContent))
            {
                HtmlChunk chunk = parser.ParseNext();
                Assert.IsNotNull(chunk);

                // checks if the HTML tag is of type div and if it has the required attributes
                Assert.IsTrue(chunk.TagName.Equals(this.htmlWrapperTag, StringComparison.Ordinal), "There is no wrapper div appended to the property representation.");
                Assert.IsTrue(chunk.HasAttribute(this.fieldAttribute), "The field attribute is not appended correctly.");
                Assert.IsTrue(chunk.HasAttribute(this.fieldTypeAttribute), "The field type attribute is not appended correctly.");

                // checks if the required attributes has proper values assigned to them
                Assert.AreEqual(fieldName, chunk.GetParamValue(this.fieldAttribute), "The value of the field attribute is not correct.");
                Assert.AreEqual(type, chunk.GetParamValue(this.fieldTypeAttribute), "The value of the fieldType attribute is not correct.");

                this.AssertContentAndCloseTag(parser);
            }
        }

        /// <summary>
        /// The get string content_ without inline editing attribute_ preserves content.
        /// </summary>
        [TestMethod]
        [Owner("Bonchev")]
        [Description("Checks whether GetStringContent method of the HtmlProcessor class properly preserves the HTML content when the property of the model is not marked with FieldInfoAttribute.")]
        public void GetStringContent_WithoutInlineEditingAttribute_PreservesContent()
        {
            // Arrange
            var htmlProcessor = new HtmlProcessor();
            var dummyWidgetModel = new DummyWidgetModel { EditableContent = this.dummyContent, NonEditableContent = this.dummyContent };

            // Act
            var nonInlineeditingAwareContent = htmlProcessor.GetStringContent(dummyWidgetModel, "NonEditableContent");

            // Assert
            Assert.AreEqual(this.dummyContent, nonInlineeditingAwareContent, "The content is not preserved correctly.");
        }

        /// <summary>
        /// The html region_ create fake html content in region_ is region properly closed.
        /// </summary>
        [TestMethod]
        [Owner("Bonchev")]
        [Description("Checks whether the HtmlRegion class properly closes a given region when disposed")]
        public void HtmlRegion_CreateFakeHtmlContentInRegion_IsRegionProperlyClosed()
        {
            // Arrange: create text writer and dummy content 
            TextWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);

            string dummyHtmlContent = string.Format(System.Globalization.CultureInfo.InvariantCulture, "<{0}>{1}", this.htmlWrapperTag, this.dummyContent);

            // Act: create the HTML region 
            using (new HtmlRegion(writer, this.htmlWrapperTag))
            {
                writer.WriteLine(dummyHtmlContent);
            }

            var outPut = writer.ToString();

            // Assert: Parses the generated by the HtmlRegion HTML checks if the HTML content is properly wrapped into a region and if this region is properly closed
            using (var parser = new HtmlParser(outPut))
            {
                var chunk = parser.ParseNext();
                Assert.IsNotNull(chunk, "Chunk shouldn't be null.");
                Assert.IsTrue(chunk.TagName.Equals(this.htmlWrapperTag, StringComparison.Ordinal), "The html tag is not div.");
                this.AssertContentAndCloseTag(parser);
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Asserts if the content is preserved and whether expected close tag is available.
        /// </summary>
        /// <param name="parser">
        /// The parser.
        /// </param>
        private void AssertContentAndCloseTag(HtmlParser parser)
        {
            string content = null;
            HtmlChunk chunk = null;
            HtmlChunk nextChunk = null;
            while ((nextChunk = parser.ParseNext()) != null)
            {
                chunk = nextChunk;
                if (nextChunk.Type == HtmlChunkType.Text)
                {
                    content = nextChunk.GenerateHtml();
                }
            }

            Assert.IsTrue(content.StartsWith(this.dummyContent, StringComparison.Ordinal), "The inner content is not preserved correctly.");
            Assert.IsTrue(chunk.TagName.Equals(this.htmlWrapperTag, StringComparison.Ordinal), "The last tag is not div.");
            Assert.IsTrue(chunk.Type == HtmlChunkType.CloseTag, "The last tag is not closing tag.");
        }

        #endregion

        #region Fields

        private readonly string dummyContent = "Lorem ipsum dolor sit amet, consectetuer adipiscing elit";
        private readonly string fieldAttribute = "data-sf-field";
        private readonly string fieldTypeAttribute = "data-sf-ftype";
        private readonly string htmlWrapperTag = "div";
        private readonly string idAttribute = "data-sf-id";
        private readonly string providerAttribute = "data-sf-provider";
        private readonly string typeAttribute = "data-sf-type";

        #endregion
    }
}